---
layout: post
title: "리스트의 정렬 여부를 체크하는 여러 방법들"
description: "파이썬의 빌트인 함수인 all과 zip의 활용법에 대한 내용을 담고 있습니다."
tags: [python tips, zip]
share: true
comments: true
---

### 정렬 여부를 체크하기 위해 많이 사용하는 방법

다음과 같은 `ages`라는 이름의 리스트가 있다고 가정해 보자. 이 리스트는 회원들의 나이를 내용으로 갖는 리스트입니다. 순서대로 잘 정리된 것처럼 보이지만 마지막의 '19, 30, 24' 부분에서 순서가 제대로 정렬되지 않은 상태이다.

```python
ages = [13, 16, 19, 30, 24]
```

값들의 정렬 여부를 확인하기 위해 다음과 같이 `sorted` 함수를 이용할 수 있다. 순서대로 정렬한 리스트가 원래 리스트와 같은지를 확인하는 원리이다.

```python
is_sorted = (sorted(ages) == ages)  # It returns False
```

또는 역순으로(숫자가 큰 것이 먼저 오도록) 정렬되어있는지 확인하고싶다면 `sorted` 함수의 결과를 인덱싱을 사용하여 순서를 바꿔주어 비교하거나 더욱 간단하게는 `sorted` 함수에 `reverse=True`라는 인자를 넣어주면 된다.

```python
is_sorted = (sorted(ages)[::-1]         == ages)
is_sorted = (sorted(ages, reverse=True) == ages)
```


### 빌트인 함수 `all` 이용하기

그러나 위에 소개된 방법은 정렬이 되었는지 체크하기 위해서 **정렬이라는 작업이 한번 수행되어야 하기 때문**에 만약에 리스트의 길이가 긴 상황에서는 시간이 많이 걸릴 수 있다. 그렇다면 리스트를 *'그대로 놔둔 상태'*에서 체크할 수 있는 방법은 없을까? 인접한 두 요소간의 비교를 여러번 하여 리스트 전체의 정렬 여부를 판단할 수 있는 방법이 있다. 예를 들면, 첫번째 숫자(13)와 두번째 숫자(16)를 비교해서 두번째 숫자가 큰지 체크해 보고, 두번째 숫자(16)와 세번째 숫자(19)를 비교하여 세번째 숫자가 큰지 체크하는 방식으로 반복적으로 체크하는 방법이다. 각 비교의 결과는 모두 `True`가 나와야만 리스트가 제대로 정렬 되었다고 말할 수 있을 것이다. 이때 빌트인 함수 `all`을 사용하면 된다. **`all`은 인자로 주어진 리스트의 모든 요소가 `True`일때 `True`를 반환하는 함수**이다. 다음과 같이 구현할 수 있다.

```python
is_sorted = all(ages[i] < ages[i+1] for i in range(len(ages)-1))
## (True, True, True, False) --> False
```

ages는 크기가 5인 리스트라서, 그보다 하나 적은 4번의 반복을 하며 앞과 뒤의 숫자를 연달아 비교한다. 맨 마지막의 비교(30과 24)에서 뒤의 숫자가 크지 않기 때문에 `False`를 반환하고, 모두가 `True`의 결과값이 아니기 때문에 `all` 함수의 결과는 당연히 `False`가 된다. 즉, 정렬되지 않았다는 것을 말해준다.


## 반복을 할 때 `range` 대신 `zip` 이용하기

자, 이제는 `range`를 쓰지 않고 `zip`함수를 써보려 한다. **`zip`은 길이가 같은 반복가능한 객체들을 인자로 여러개 받아들여 순서대로 각 객체들에 있는 요소들을 앞에서부터 각각 하나씩 순서대로 반환하는 함수**이다. 다음의 코드를 통해 더욱 자세히 설명하려고 한다.

```python
agesX = ages[:-1]  # [13, 16, 19, 30]
agesY = ages[1:]   # [16, 19, 30, 24]

for x, y in zip(agesX, agesY):
    print(x, y)
    # 13, 16
    # 16, 19
    # 19, 30
    # 30, 24
```

`ages[:-1]`는 리스트 `ages`가 갖고 있는 맨 뒤의 숫자인 24만 제외한 리스트이며, `ages[1:]`는 그와 반대로 맨 앞의 숫자인 13만 제외한 리스트이다. 이 둘은 한 숫자만 제외하였으므로 길이가 같다. 이 둘을 `zip` 함수에 넣어주면 두 리스트의 요소들이 각각 하나씩 순서대로 리턴되는 것을 볼 수 있다. 그렇지만 이러한 동작의 의미를 달리 해석해 보면 `ages`라는 리스트에서 인접한 두 쌍을 계속 리턴하는 방법으로 생각할 수 있다. 따라서 인접한 두 숫자를 비교하는 데에도 사용할 수 있는 것이다.

```python
is_sorted = all(x<y for x, y in zip(ages[:-1], ages[1:]))  # check if it is sorted in ascending order
is_sorted = all(x>y for x, y in zip(ages[:-1], ages[1:]))  # check if it is sorted in descending order
```

이것의 장점은 우리가 마음대로 판단의 내용을 정할 수 있다는 것이다. 정순으로 정렬하고 싶으면 `x<y`, 역순으로 정렬하고 싶으면 `x>y`로 해주면 된다.