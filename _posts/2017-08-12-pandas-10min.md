---
layout: post
title: "Pandas 기본 사용법 익히기"
image: /images/2017-08-12/cover.png
description: "Pandas의 기본 사용법을 소개해 놓은 '10 Minutes to pandas' 문서를 따라해 본 글입니다."
tags: [python, pandas, 10min]
share: true
comments: true
---

> 본 포스트는 pandas의 기본 사용법을 소개해 놓은 [10 Minutes to pandas](https://pandas.pydata.org/pandas-docs/stable/10min.html)
을 따라 실습해 보면서 한글로 번역하고 추가설명을 달아 놓은 글입니다. 이해를 돕기 위해 추가설명을 달다 보니 원글과 달리
제 글을 10분만에 읽기는 불가능해졌군요. :-) 차근차근 실습을 해 보면서 pandas의 기본 사용법을 익히시려는 분들께 도움이
되었으면 좋겠습니다.

pandas를 사용하기 위해서 관례적으로 다음과 같이 모듈을 임포트(import) 합니다. pandas 외에도 배열 구조나 랜덤 값 생성
등의 기능을 활용하기 위한 numpy와 그래프를 그리기 위한 matplotlib도 함께 임포트 해줍니다.

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
```

## 목차

1. [데이터 오브젝트 생성하기 (Object Creation)](#ch1)
2. [데이터 확인하기 (Viewing Data)](#ch2)
3. [데이터 선택하기 (Selection)](#ch3)
4. [결측치 (Missing Data)](#ch4)
5. [연산 (Operations)](#ch5)
6. [합치기 (Merge)](#ch6)
7. [묶기 (Grouping)](#ch7)
8. [변형하기 (Reshaping)](#ch8)
9. [시계열 데이터 다루기 (Time Series)](#ch9)
10. [카테고리 (Categoricals)](#ch10)
11. [그래프로 그리기 (Plotting)](#ch11)
12. [데이터 입/출력 (Getting Data In/Out)](#ch12)

## <a name="ch1"></a>1. 데이터 오브젝트 생성하기

Pandas에서 제공하는 자료 구조들이 무엇이 있는지 알아보시려면 pandas documentation에 있는
[Data Structure Intro section](https://pandas.pydata.org/pandas-docs/stable/dsintro.html#dsintro)을 참고하시면 됩니다.

Pandas의 데이터 구조 중 하나인 **Series**는 다음과 같이 값들의 리스트를 넘겨주어 만들게 됩니다. 인덱스는 자동적으로
기본적으로 지정되는 정수 인덱스를 사용합니다.

```python
s = pd.Series([1, 3, 5, np.nan, 6, 8])

# 0    1.0
# 1    3.0
# 2    5.0
# 3    NaN
# 4    6.0
# 5    8.0
# dtype: float64
```

또 다른 데이터 구조인 **DataFrame**은 numpy array를 받아 생성이 가능합니다. 여기에서는 인덱스로 날짜 값을 주었고,
컬럼의 이름도 같이 넣어보았습니다.

```python
dates = pd.date_range('20130101', periods=6)
# DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
#                '2013-01-05', '2013-01-06'],
#               dtype='datetime64[ns]', freq='D')

df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))
#                   A         B         C         D
# 2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860
# 2013-01-05 -0.424972  0.567020  0.276232 -1.087401
# 2013-01-06 -0.673690  0.113648 -1.478427  0.524988
```

또는 다음과 같이 Series 처럼 변환 가능한 오브젝트들을 갖고 있는 dict의 형태를 인자로 넣어주어 DataFrame을 만들 수
있습니다. 이 때, index는 자동으로 0부터 시작하여 1씩 증가하는 정수 인덱스가 부여되고, dict의 키 값을 컬럼의 이름으로
사용하게 됩니다.

```python
df2 = pd.DataFrame({'A': 1.,
                    'B': pd.Timestamp('20130102'),
                    'C': pd.Series(1, index=list(range(4)), dtype='float32'),
                    'D': np.array([3]*4, dtype='int32'),
                    'E': pd.Categorical(['test', 'train', 'test', 'train']),
                    'F': 'foo'})
#      A          B    C  D      E    F
# 0  1.0 2013-01-02  1.0  3   test  foo
# 1  1.0 2013-01-02  1.0  3  train  foo
# 2  1.0 2013-01-02  1.0  3   test  foo
# 3  1.0 2013-01-02  1.0  3  train  foo
```

DataFrame의 컬럼들은 각기 특별한 자료형을 갖고 있습니다. 이는 DataFrame 내에 있는 dtypes라는 속성을 통해 확인
가능합니다. 파이썬의 기본적인 소수점은 float64로 잡히고, 기본적은 문자열은 str이 아니라 object라는 자료형으로
나타납니다.

```python
df2.dtypes
# A           float64
# B    datetime64[ns]
# C           float32
# D             int32
# E          category
# F            object
# dtype: object
```

Jupyter를 사용하시는 분이라면 `df2.<TAB>`('df2.'까지 입력하고 탭을 누름)을 통해 다음과 같이 dtypes 외에도 다른 속성들이
무엇이 있는지 확인할 수 있습니다.

```
In [13]: df2.<TAB>
df2.A                  df2.bool
df2.abs                df2.boxplot
df2.add                df2.C
df2.add_prefix         df2.clip
df2.add_suffix         df2.clip_lower
df2.align              df2.clip_upper
df2.all                df2.columns
df2.any                df2.combine
df2.append             df2.combine_first
df2.apply              df2.compound
df2.applymap           df2.consolidate
df2.as_blocks          df2.convert_objects
df2.asfreq             df2.copy
df2.as_matrix          df2.corr
df2.astype             df2.corrwith
df2.at                 df2.count
df2.at_time            df2.cov
df2.axes               df2.cummax
df2.B                  df2.cummin
df2.between_time       df2.cumprod
df2.bfill              df2.cumsum
df2.blocks             df2.D
```

보다시피 컬럼 A, B, C, D가 자동적으로 생성되어 나타나는 것을 확인할 수 있습니다. 나머지 속성들은 간결성을 위해
생략하였기 때문에 E도 뒤에 있을 것입니다.

Ipython을 사용하지 않는 분이라면, python의 빌트인 함수 `dir`을 통해 다음과 같이 오브젝트가 갖고 있는 속성들을 모두 확인
가능합니다. (약 400개가 넘는 항목입니다. 엄청 많습니다.)

```python
dir(df2)
# ['A', 'B', 'C', ... , 'values', 'var', 'where', 'xs']
```


## <a name="ch2"></a>2. 데이터 확인하기 (Viewing Data)

이 부분에 대해 더 자세히 알고 싶으시면 [Basics section](https://pandas.pydata.org/pandas-docs/stable/basics.html#basics)
을 참고해주세요.

DataFrame에 들어있는 자료들을 확인하기 위해 맨 앞이나 뒤의 자료들 몇 개를 알아보고 싶다면 다음과 같이 `.head()`와
`.tail()` 메소드를 사용하면 됩니다. 기본적으로 5개의 자료를 보여주고, 더 적게 혹은 많이 보고 싶다면 메소드의 인자로
보고싶은 데이터의 개수를 숫자를 넣어주면 됩니다.

```python
## 첫 5개 행의 데이터를 보여줍니다.
df.head()
#                    A         B         C         D
# 2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860
# 2013-01-05 -0.424972  0.567020  0.276232 -1.087401

## 마지막 3개 행의 데이터를 보여줍니다.
df.tail(3)
#                    A         B         C         D
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860
# 2013-01-05 -0.424972  0.567020  0.276232 -1.087401
# 2013-01-06 -0.673690  0.113648 -1.478427  0.524988
```

DataFrame의 인덱스를 보려면 `.index` 속성을, 컬럼을 보려면 `.columns` 속성을, 안에 들어있는 numpy 데이터를 보려면
`.values` 속성을 통해 확인하면 됩니다.

```python
df.index
# DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
#                '2013-01-05', '2013-01-06'],
#               dtype='datetime64[ns]', freq='D')

df.columns
# Index(['A', 'B', 'C', 'D'], dtype='object')

df.values
# [[ 0.4691, -0.2829, -1.5091, -1.1356],
#  [ 1.2121, -0.1732,  0.1192, -1.0442],
#  [-0.8618, -2.1046, -0.4949,  1.0718],
#  [ 0.7216, -0.7068, -1.0396,  0.2719],
#  [-0.425 ,  0.567 ,  0.2762, -1.0874],
#  [-0.6737,  0.1136, -1.4784,  0.525 ]]
```

`.describe()` 메소드는 생성했던 DataFrame의 간단한 통계 정보를 보여줍니다. 컬럼별로 데이터의 개수(count), 데이터의 평균
값(mean), 표준 편차(std), 최솟값(min), 4분위수(25%, 50%, 75%), 그리고 최댓값(max)들의 정보를 알 수 있습니다.

```python
df.describe()
#               A         B         C         D
# count  6.000000  6.000000  6.000000  6.000000
# mean   0.073711 -0.431125 -0.687758 -0.233103
# std    0.843157  0.922818  0.779887  0.973118
# min   -0.861849 -2.104569 -1.509059 -1.135632
# 25%   -0.611510 -0.600794 -1.368714 -1.076610
# 50%    0.022070 -0.228039 -0.767252 -0.386188
# 75%    0.658444  0.041933 -0.034326  0.461706
# max    1.212112  0.567020  0.276232  1.071804
```

`.T` 속성은 DataFrame에서 index와 column을 바꾼 형태의 DataFrame 입니다.
[pandas documentation](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.T.html)에는 `.T`를
'Transpose index and columns'와 같이 설명해 놓고 있어서 index와 column을 바꾼 후 리턴값으로 돌려주는 메소드로 착각할
수 있습니다. 따라서 `.T()`로 호출하는 경우가 있으실 텐데, 그렇게 해보니 에러가 나는군요. 메소드가 아니라 미리 계산되어
저장되어 있는 '속성'이라는 점을 다시 강조합니다.

```python
## 열과 행을 바꾼 형태의 데이터프레임입니다.
df.T
#    2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
# A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690
# B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648
# C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427
# D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988

## .T는 속성임을 알아두세요. 다음과 같이 메소드로 호출한다면 에러를 냅니다.
df.T()
# Traceback (most recent call last):
#   File "./main.py", line 5, in __main__
#     dfT = df.T()
# TypeError: 'DataFrame' object is not callable
```

그리고 `.sort_index()`라는 메소드로 행과 열 이름을 정렬하여 나타낼 수도 있습니다. 정렬할 대상 축을 결정할 때에는
`axis`를 이용합니다. `axis=0`라고 써주면 인덱스를 기준으로 정렬하겠다는 것이고(기본값), `axis=1`라고 써주면 컬럼을
기준으로 정렬하겠다는 것입니다. 정렬의 방향은 `ascending`을 이용합니다. `ascending=True`는 오름차순 정렬을 하겠다는
것이고(기본값), `ascending=False`는 내림차순 정렬을 하겠다는 의미입니다. 다음은 컬럼에 대하여 내림차순 정렬을 하는
예제입니다.

```python
df.sort_index(axis=1, ascending=False)
#                    D         C         B         A
# 2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
# 2013-01-02 -1.044236  0.119209 -0.173215  1.212112
# 2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
# 2013-01-04  0.271860 -1.039575 -0.706771  0.721555
# 2013-01-05 -1.087401  0.276232  0.567020 -0.424972
# 2013-01-06  0.524988 -1.478427  0.113648 -0.673690
```

또한 DataFrame 내부에 있는 값으로 정렬할 수도 있습니다. 다음은 B 컬럼에 대해 정렬한 결과를 보여줍니다.

```python
df.sort_values(by='B')
#                    A         B         C         D
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860
# 2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-06 -0.673690  0.113648 -1.478427  0.524988
# 2013-01-05 -0.424972  0.567020  0.276232 -1.087401
```

## <a name="ch3"></a>3. 데이터 선택하기 (Selection)

데이터프레임 자체가 갖고 있는 `[]` 슬라이싱 기능을 이용하는 방법입니다. 특정 '컬럼'의 값들만 가져오고 싶다면 `df['A']`와
같은 형태로 입력합니다. 이는 `df.A`와 동일합니다. 리턴되는 값은 Series의 자료구조를 갖고 있습니다.

```python
## A라는 이름을 가진 컬럼의 데이터만 갖고옵니다.
df['A']
# 2013-01-01    0.469112
# 2013-01-02    1.212112
# 2013-01-03   -0.861849
# 2013-01-04    0.721555
# 2013-01-05   -0.424972
# 2013-01-06   -0.673690
# req: D, Name: A, dtype: float64

type(df['A'])
# <class 'pandas.core.series.Series'>
```

여러분의 이해를 돕기 위해 그림으로 다시 나타내면 다음과 같습니다. (앞으로 나오는 예제들도 그림으로 한번 더 설명하겠습니다.)

![Select column A](/images/2017-08-12/fig1.png?gray "Select column A"){: .center-image}

특정 '행 범위'를 가져오고 싶다면 다음과 같이 리스트를 슬라이싱 할 때와 같이 `[]`를 이용할 수 있습니다. `df[0:3]`라고
하면 0, 1, 2번째 행을 가져옵니다(데이터프레임의 첫번째 행을 0번째 행이라고 가정). `[0:3]`이라고 입력했지만 3번째 행을
가져오지 않음에 유의합니다. 또 다른 방법으로 `df['20130102':'20130104']` 인덱스명을 직접 넣어서 해당하는 '행 범위'를
가져올 수도 있습니다. 이 때에는 숫자를 이용하여 슬라이싱 할 때와 달리 처음과 끝의 행이 모두 포함된 결과를 가져옵니다.

```python
## 맨 처음 3개의 행을 가져옵니다.
df[0:3]
#                    A         B         C         D
# 2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

## 인덱스명에 해당하는 값들을 가져옵니다.
df['20130102':'20130104']
#                    A         B         C         D
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860
```

![Image](/images/2017-08-12/fig2.png?gray "Select rows"){: .center-image}

여기서 제가 왜 특정 '행'이 아니라 '행 범위'라고 강조하였는지를 설명드리겠습니다. 만약 특정 행 하나를 가져오고 싶은
경우에 `df['20130102']`라고 하면 KeyError가 발생합니다. 왜일까요? 이 때에는 '20130102'라는 이름의 '인덱스'가 아니라
'컬럼'을 갖고 있는지 찾게 됩니다. 따라서 현재 데이터프레임에는 없으므로 키 값이 없다는 에러를 출력하게 되는 것입니다.
특정 '행 하나'를 선택하고 싶을 때에는 `df['20130102':'20130102']`와 같이 입력하면 됩니다. 다시 정리하자면, 데이터프레임
자체가 갖고 있는 슬라이싱은 `df[컬럼명]`, `df[시작인덱스:끝인덱스+1]`, `df[시작인덱스명:끝인덱스명]`의 형태로 사용할 수
있습니다.


### 이름을 이용하여 선택하기: `.loc`

라벨의 이름을 이용하여 선택할 수 있는 `.loc`를 이용할 수도 있습니다. 첫 번째 인덱스의 값인 '2013-01-01'에 해당하는 모든
컬럼의 값 가져오기. `df.loc[dates[0]]` 외에도 `df.loc['20130101']` 또는 `df.loc['2013-01-01']` 처럼 날짜를 직접 입력해도
잘 작동합니다.

```python
df.loc[dates[0]]
# A    0.469112
# B   -0.282863
# C   -1.509059
# D   -1.135632
# Name: 2013-01-01 00:00:00, dtype: float64
```

![Image](/images/2017-08-12/fig3.png?gray "Select rows"){: .center-image}

컬럼 'A'와 컬럼 'B'에 대한 모든 값 가져오기.

```python
df.loc[:,['A','B']]
#                    A         B
# 2013-01-01  0.469112 -0.282863
# 2013-01-02  1.212112 -0.173215
# 2013-01-03 -0.861849 -2.104569
# 2013-01-04  0.721555 -0.706771
# 2013-01-05 -0.424972  0.567020
# 2013-01-06 -0.673690  0.113648
```

![Image](/images/2017-08-12/fig4.png?gray "Select rows"){: .center-image}

인덱스 '2013-01-02'부터 '2013-01-04'까지의 컬럼 'A'와 컬럼 'B'의 값 가져오기.

```python
df.loc['20130102':'20130104',['A','B']]
#                    A         B
# 2013-01-02  1.212112 -0.173215
# 2013-01-03 -0.861849 -2.104569
# 2013-01-04  0.721555 -0.706771
```

![Image](/images/2017-08-12/fig5.png?gray "Select rows"){: .center-image}

특정 인덱스 값의 컬럼 'A', 'B' 값을 가져오기.

```python
df.loc[dates[0], ['A','B']]
# A    1.212112
# B   -0.173215
# Name: 2013-01-02 00:00:00, dtype: float64
```

![Image](/images/2017-08-12/fig6.png?gray "Select rows"){: .center-image}

특정 인덱스 값과 특정 컬럼에 있는 값 가져오기. 이는 `.at`을 이용할 수도 있습니다.

```python
df.loc[dates[0],'A']
# 0.46911229990718628

df.at[dates[0], 'A']
# 0.46911229990718628
```

![Image](/images/2017-08-12/fig7.png?gray "Select rows"){: .center-image}


### 위치를 이용하여 선택하기: `.iloc`

다음과 같이 위치를 나타내는 인덱스 번호를 이용하여 데이터를 선택할 수 있습니다. 여기서 인덱스 번호는 python에서 사용하는
인덱스와 같은 개념으로 이해하시면 됩니다. 인덱스 번호는 0 부터 시작하므로, 첫 번째 데이터는 인덱스 번호가 0 이고,
두 번째 데이터는 인덱스 번호가 1 이라는 뜻입니다. 아래는 인덱스 번호 3 (네 번째 행)을 선택하는 예제입니다.

```python
df.iloc[3]
# A    0.721555
# B   -0.706771
# C   -1.039575
# D    0.271860
# Name: 2013-01-04 00:00:00, dtype: float64
```

![Image](/images/2017-08-12/fig8.png "df.iloc[3]"){: .center-image}

인덱스 번호로 행 뿐만 아니라 열도 선택할 수 있습니다. 또한 numpy나 python의 슬라이싱 기능과 비슷하게 사용할 수 있습니다.
아래는 행과 열의 인덱스를 기준으로 이용하여 데이터를 선택하는 예제입니다. 행의 인덱스는 `3:5`로 네 번째 행과 다섯 번째
행을 선택하며, 열의 인덱스는 `0:2`로 첫 번째 열과 두 번째 열을 선택합니다.

```python
df.iloc[3:5,0:2]
#                    A         B
# 2013-01-04  0.721555 -0.706771
# 2013-01-05 -0.424972  0.567020
```

![Image](/images/2017-08-12/fig9.png "Select subset 1"){: .center-image}

또한 행과 열의 인덱스를 리스트로 넘겨줄 수도 있습니다. 다음은 두 번째, 세 번째, 다섯 번째 행과, 첫 번째와 세 번째 열을
선택하는 예제입니다.

```python
df.iloc[[1,2,4],[0,2]]
#                    A         C
# 2013-01-02  1.212112  0.119209
# 2013-01-03 -0.861849 -0.494929
# 2013-01-05 -0.424972  0.276232
```

![Image](/images/2017-08-12/fig10.png "Select subset 2"){: .center-image}

명시적으로 행이나 열 선택 인자에 `:` 슬라이스를 전달하면 다음과 같이 행 또는 열 전체를 가져올 수도 있습니다.

```python
df.iloc[1:3,:]
#                    A         B         C         D
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

df.iloc[:,1:3]
#                    B         C
# 2013-01-01 -0.282863 -1.509059
# 2013-01-02 -0.173215  0.119209
# 2013-01-03 -2.104569 -0.494929
# 2013-01-04 -0.706771 -1.039575
# 2013-01-05  0.567020  0.276232
# 2013-01-06  0.113648 -1.478427
```

![Image](/images/2017-08-12/fig11.png "Select rows/cols"){: .center-image}

값 하나를 선택하기 위해서는 특정 행과 열을 지정하는 방식으로 하면 됩니다. 아래의 두 방법 모두 동일한 방법입니다.

```python
df.iloc[1,1]
# -0.17321464905330858
df.iat[1,1]
# -0.17321464905330858
```

![Image](/images/2017-08-12/fig12.png "Select scalar"){: .center-image}


이 부분에 대해 더 많은 사용법을 원하신다면
[위치를 이용한 데이터 선택](https://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-integer)을 참고하시면
됩니다.


### 조건을 이용하여 선택하기

특정한 열의 값들을 기준으로 조건을 만들어 해당 조건에 만족하는 행들만 선택할 수 있는 방법이 있습니다. 다음은 A라는 열에
들어있는 값이 양수인 경우에 해당하는 행들을 선택하는 예제입니다.

```python
df[df.A > 0]
#                    A         B         C         D
# 2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860
```

또한 각 값을 기준으로 조건을 만들 수도 있습니다. 이 때에는 행이 선택되는 것이 아니라 데이터 프레임의 전체 모양은 유지된
채로 조건에 맞는 값들만 그대로 보여지고 나머지 값들은 추후에 배울 결측치(missing value)로 나타나게 됩니다. 다음은 값이
양수인 것들만 보여지고 나머지 값들(0 혹은 음수)은 NaN 으로 보여지는 예제입니다.

```python
df[df > 0]
#                    A         B         C         D
# 2013-01-01  0.469112       NaN       NaN       NaN
# 2013-01-02  1.212112       NaN  0.119209       NaN
# 2013-01-03       NaN       NaN       NaN  1.071804
# 2013-01-04  0.721555       NaN       NaN  0.271860
# 2013-01-05       NaN  0.567020  0.276232       NaN
# 2013-01-06       NaN  0.113648       NaN  0.524988
```

또한 필터링을 해야 하는 경우에 사용할 수 있는 `isin()`이라는 메소드도 제공합니다. 다음과 같이 새로운 열 하나를 추가한 후
새롭게 추가된 열에 들어있는 값을 기준으로 행을 선택할 수 있습니다.

```python
df2 = df.copy()
df2['E'] = ['one', 'one','two','three','four','three']

df2
#                    A         B         C         D      E
# 2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
# 2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
# 2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
# 2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
# 2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

df2[df2['E'].isin(['two', 'four'])]
#                    A         B         C         D     E
# 2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
# 2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four
```

### 데이터 변경하기

우리가 선택했던 데이터 프레임의 특정 값들을 다른 값으로 변경할 수 있습니다. 이에 대한 방법을 알아봅니다.

기존 데이터 프레임에 새로운 열을 추가하고 싶을 때는 다음과 같이 같은 인덱스를 가진 시리즈 하나를 데이터 프레임의 열 하나
를 지정하여 넣어 줍니다.

```python
s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))

s1
# 2013-01-02    1
# 2013-01-03    2
# 2013-01-04    3
# 2013-01-05    4
# 2013-01-06    5
# 2013-01-07    6
# Freq: D, dtype: int64

df['F'] = s1
```

데이터 프레임의 특정 값 하나를 선택하여 다른 값으로 바꿀 수 있습니다.

```python
df.at[dates[0], 'A'] = 0
```

앞서 배운 값의 위치(인덱스 번호)를 이용한 변경도 가능합니다.

```python
df.iat[0,1] = 0
```

여러 값을 한꺼번에 바꾸고 싶을 때는 데이터의 크기만 잘 맞춰 주면 됩니다. 다음은 NumPy array를 이용한 방법입니다.

```python
df.loc[:,'D'] = np.array([5] * len(df))
```

앞에서 바꾼 데이터들을 모두 적용하여 데이터 프레임의 값들을 한번 살펴보겠습니다.

```python
df
#                    A         B         C  D    F
# 2013-01-01  0.000000  0.000000 -1.509059  5  NaN
# 2013-01-02  1.212112 -0.173215  0.119209  5  1.0
# 2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0
# 2013-01-04  0.721555 -0.706771 -1.039575  5  3.0
# 2013-01-05 -0.424972  0.567020  0.276232  5  4.0
# 2013-01-06 -0.673690  0.113648 -1.478427  5  5.0
```

앞서 배운 조건을 이용한 데이터 선택 방법을 이용하여 다음과 같이 특정 조건에 만족하는 값들만 변경할 수도 있습니다. 다음은
양수의 값을 가지는 값들에 한해서 음수로 바꿔주는 예제입니다. 결국에는 0 또는 음수만을 가지는 데이터 프레임을 만들 수
있습니다.

```python
df2 = df.copy()
df2[df2 > 0] = -df2

df2
#                    A         B         C  D    F
# 2013-01-01  0.000000  0.000000 -1.509059 -5  NaN
# 2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0
# 2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0
# 2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0
# 2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0
# 2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0
```

## <a name="ch4"></a>4. 결측치 (Missing Data)

결측치란 (어떤 이유로 인해) 측정되지 못한 데이터 값을 말합니다.


## <a name="ch5"></a>5. 연산 (Operations)

### 통계적 지표들

평균 구하기. 일반적으로 결측치는 제외하고 연산을 합니다.

```python
df.mean()
# A   -0.004474
# B   -0.383981
# C   -0.687758
# D    5.000000
# F    3.000000
# dtype: float64
```

다른 축에 대해서 평균 구하기. `mean()` 함수의 인자로 1을 주게 되면 컬럼이 아닌 인덱스를 기준으로 연산을 합니다.

```python
df.mean(1)
# 2013-01-01    0.872735
# 2013-01-02    1.431621
# 2013-01-03    0.707731
# 2013-01-04    1.395042
# 2013-01-05    1.883656
# 2013-01-06    1.592306
# Freq: D, dtype: float64
```


## <a name="ch6"></a>6. 합치기 (Merging)




## <a name="ch7"></a>7. 묶기 (Grouping)




## <a name="ch8"></a>8. 변형하기 (Reshaping)




## <a name="ch9"></a>9. 시계열 데이터 다루기 (Time Series)




## <a name="ch10"></a>10. 카테고리 (Categoricals)




## <a name="ch11"></a>11. 그래프로 그리기 (Plotting)

다음과 같은 시계열 데이터가 있을 때, 그래프 그리기는 다음과 같이 `plot()` 메소드 하나만으로 완성할 수 있다.

```python
ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))
ts = ts.cumsum()
ts.plot()
```

![Image](https://pandas.pydata.org/pandas-docs/stable/_images/series_plot_basic.png "Plotting"){: .center-image}

`plot()` 메소드는 여러 개의 열을 한 번에 그릴 수 있는 편리함도 제공하고 있다. 다음과 같이 A, B, C, D의 4개의 열에
해당하는 데이터를 legend 와 함께 표시할 수 있다.

```python
df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, columns=['A', 'B', 'C', 'D'])
df = df.cumsum()
plt.figure(); df.plot(); plt.legend(loc='best')
```

![Image](https://pandas.pydata.org/pandas-docs/stable/_images/frame_plot_basic.png "Plotting multiple cols"){: .center-image}

그래프를 그리는 더욱 자세한 방법은
[그래프 그리기](https://pandas.pydata.org/pandas-docs/stable/visualization.html#visualization) 항목을 참고하시기
바랍니다. 

## <a name="ch12"></a>12. 데이터 입/출력 (Getting Data In/Out)

데이터를 다양한 형식의 파일에 읽고 쓰는 방법을 알아봅니다.

### CSV

데이터 프레임을 CSV 형식으로 저장하기.

```python
df.to_csv('foo.csv')
```

CSV 형식으로 된 파일로부터 데이터 프레임의 형식으로 읽어오기. CSV 형식으로 부터 읽어올 때 주의할 점은 기존 행 인덱스를
인식하지 못하고 행 인덱스를 가지는 새로운 열이 추가로 잡힌다는 것입니다. 따라서 저장할 당시에는 4개였던 열의 개수가
5개가 되어있는 것을 확인할 수 있습니다.

```python
pd.read_csv('foo.csv')
#      Unnamed: 0          A          B         C          D
# 0    2000-01-01   0.266457  -0.399641 -0.219582   1.186860
# 1    2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
# 2    2000-01-03  -1.734933   0.530468  2.060811  -0.515536
# 3    2000-01-04  -1.555121   1.452620  0.239859  -1.156896
# 4    2000-01-05   0.578117   0.511371  0.103552  -2.428202
# 5    2000-01-06   0.478344   0.449933 -0.741620  -1.962409
# 6    2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
# ..          ...        ...        ...       ...        ...
# 993  2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
# 994  2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
# 995  2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
# 996  2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
# 997  2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
# 998  2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
# 999  2002-09-26 -11.856774 -10.671012 -3.216025  29.369368
# 
# [1000 rows x 5 columns]
```

### HDF5

HDF5 형식으로 저장하기.

```python
df.to_hdf('foo.h5', 'df')
```

HDF5 형식으로부터 읽어오기.

```python
pd.read_hdf('foo.h5', 'df')
#                     A          B         C          D
# 2000-01-01   0.266457  -0.399641 -0.219582   1.186860
# 2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
# 2000-01-03  -1.734933   0.530468  2.060811  -0.515536
# 2000-01-04  -1.555121   1.452620  0.239859  -1.156896
# 2000-01-05   0.578117   0.511371  0.103552  -2.428202
# 2000-01-06   0.478344   0.449933 -0.741620  -1.962409
# 2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
# ...               ...        ...       ...        ...
# 2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
# 2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
# 2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
# 2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
# 2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
# 2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
# 2002-09-26 -11.856774 -10.671012 -3.216025  29.369368
# 
# [1000 rows x 4 columns]
```

### Excel

데이터 프레임을 엑셀 파일로 저장하기.

```python
df.to_excel('foo.xlsx', sheet_name='Sheet1')
```

엑셀 파일로부터 데이터 프레임 읽어오기.

```python
pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA'])
#                     A          B         C          D
# 2000-01-01   0.266457  -0.399641 -0.219582   1.186860
# 2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
# 2000-01-03  -1.734933   0.530468  2.060811  -0.515536
# 2000-01-04  -1.555121   1.452620  0.239859  -1.156896
# 2000-01-05   0.578117   0.511371  0.103552  -2.428202
# 2000-01-06   0.478344   0.449933 -0.741620  -1.962409
# 2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
# ...               ...        ...       ...        ...
# 2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
# 2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
# 2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
# 2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
# 2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
# 2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
# 2002-09-26 -11.856774 -10.671012 -3.216025  29.369368
# 
# [1000 rows x 4 columns]
```
